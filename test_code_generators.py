#!/usr/bin/env python3
"""
Test script for all simplified code generators.

Tests the following generators:
1. Parallel RCT: binary, continuous, survival
2. Cluster RCT: binary, continuous

Verifies that each generator:
- Can be imported successfully
- Returns a string with Python code
- Generated code contains expected elements
- Code is in simplified style (19-26 lines, not 160+ lines)
"""

import sys
import os
import importlib.util
import tempfile
import traceback

def test_import_and_call_generator(module_path, function_name, test_params):
    """Test importing and calling a specific generator function."""
    print(f"\n{'='*60}")
    print(f"Testing: {module_path} -> {function_name}")
    print(f"{'='*60}")
    
    try:
        # Import the module
        module_name = module_path.replace('/', '.').replace('.py', '')
        if module_name.startswith('.'):
            module_name = module_name[1:]
        
        module = importlib.import_module(module_name)
        
        # Get the function
        if not hasattr(module, function_name):
            print(f"❌ FAILED: Function '{function_name}' not found in module")
            return False
        
        generator_func = getattr(module, function_name)
        print(f"✅ Successfully imported {function_name}")
        
        # Call the function with test parameters
        generated_code = generator_func(test_params)
        
        # Verify it returns a string
        if not isinstance(generated_code, str):
            print(f"❌ FAILED: Function returned {type(generated_code)}, expected string")
            return False
        
        print(f"✅ Function returned a string ({len(generated_code)} characters)")
        
        # Verify it's not empty
        if not generated_code.strip():
            print(f"❌ FAILED: Generated code is empty")
            return False
        
        # Count lines (excluding empty lines)
        lines = [line for line in generated_code.split('\n') if line.strip()]
        line_count = len(lines)
        print(f"✅ Generated code has {line_count} non-empty lines")
        
        # Check if it's in simplified style (should be around 19-26 lines, not 160+)
        if line_count > 50:
            print(f"⚠️  WARNING: Code seems too long ({line_count} lines) - may not be simplified style")
        elif line_count < 15:
            print(f"⚠️  WARNING: Code seems too short ({line_count} lines) - may be incomplete")
        else:
            print(f"✅ Code length looks appropriate for simplified style")
        
        # Check for expected elements
        expected_elements = [
            'from core.designs',  # Import statement
            'def ',               # Should not contain function definitions (generated code should be standalone)
            'result =',           # Should have result assignment
            'print(',             # Should have print statements
            'json.dumps',         # Should have JSON output
            '# Generated by DesignPower'  # Should have header comment
        ]
        
        print("\nChecking for expected code elements:")
        for element in expected_elements:
            if element == 'def ' and element in generated_code:
                print(f"⚠️  WARNING: Found 'def ' - generated code should not contain function definitions")
            elif element == 'def ':
                print(f"✅ No function definitions found (good)")
            elif element in generated_code:
                print(f"✅ Found: {element}")
            else:
                print(f"❌ Missing: {element}")
        
        # Show first few lines of generated code
        print(f"\nFirst 10 lines of generated code:")
        print("-" * 40)
        for i, line in enumerate(generated_code.split('\n')[:10], 1):
            print(f"{i:2d}: {line}")
        
        # Try to write and parse the code (basic syntax check)
        try:
            compile(generated_code, '<generated_code>', 'exec')
            print(f"✅ Generated code has valid Python syntax")
        except SyntaxError as e:
            print(f"❌ SYNTAX ERROR in generated code: {e}")
            return False
        
        print(f"✅ {function_name} test PASSED")
        return True
        
    except Exception as e:
        print(f"❌ FAILED: {e}")
        traceback.print_exc()
        return False


def main():
    """Run all generator tests."""
    print("Testing all simplified code generators")
    print("=" * 80)
    
    # Add the project root to Python path
    project_root = os.path.dirname(os.path.abspath(__file__))
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    
    # Test cases for each generator
    test_cases = [
        # Parallel RCT Binary
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_binary',
            'params': {
                'calculation_type': 'Power',
                'hypothesis_type': 'Superiority', 
                'method': 'analytical',
                'n1': 100,
                'n2': 100,
                'p1': 0.3,
                'p2': 0.5,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0,
                'nsim': 1000,
                'seed': 42,
                'test_type': 'normal_approximation'
            }
        },
        
        # Parallel RCT Binary - Sample Size
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_binary',
            'params': {
                'calculation_type': 'Sample Size',
                'hypothesis_type': 'Superiority',
                'method': 'simulation',
                'p1': 0.3,
                'p2': 0.5,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0,
                'nsim': 1000,
                'seed': 42,
                'test_type': 'fishers_exact'
            }
        },
        
        # Parallel RCT Binary - Non-Inferiority
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_binary',
            'params': {
                'calculation_type': 'Power',
                'hypothesis_type': 'Non-Inferiority',
                'method': 'analytical',
                'n1': 100,
                'n2': 100,
                'p1': 0.3,
                'non_inferiority_margin': 0.05,
                'alpha': 0.05,
                'assumed_difference_ni': 0.0,
                'non_inferiority_direction': 'higher',
                'allocation_ratio': 1.0
            }
        },
        
        # Parallel RCT Continuous
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_continuous',
            'params': {
                'calculation_type': 'Power',
                'hypothesis_type': 'Superiority',
                'method': 'analytical',
                'n1': 100,
                'n2': 100,
                'mean1': 10.0,
                'mean2': 12.0,
                'std_dev': 5.0,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0
            }
        },
        
        # Parallel RCT Continuous - Sample Size
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_continuous',
            'params': {
                'calculation_type': 'Sample Size',
                'hypothesis_type': 'Superiority',
                'method': 'simulation',
                'mean1': 10.0,
                'mean2': 12.0,
                'std_dev': 5.0,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0,
                'nsim': 1000,
                'seed': 42
            }
        },
        
        # Parallel RCT Continuous - Non-Inferiority
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_continuous',
            'params': {
                'calculation_type': 'Power',
                'hypothesis_type': 'Non-Inferiority',
                'method': 'analytical',
                'n1': 100,
                'n2': 100,
                'mean1': 10.0,
                'std_dev': 5.0,
                'non_inferiority_margin': 1.0,
                'alpha': 0.05,
                'assumed_difference_ni': 0.0,
                'non_inferiority_direction': 'higher',
                'allocation_ratio': 1.0
            }
        },
        
        # Parallel RCT Survival
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_survival',
            'params': {
                'calculation_type': 'Power',
                'hypothesis_type': 'Superiority',
                'method': 'analytical',
                'n1': 150,
                'n2': 150,
                'median1': 12.0,
                'median2': 18.0,
                'enrollment_period': 12.0,
                'follow_up_period': 12.0,
                'dropout_rate': 0.1,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0
            }
        },
        
        # Parallel RCT Survival - Sample Size
        {
            'module': 'app.components.parallel_rct',
            'function': 'generate_cli_code_parallel_survival',
            'params': {
                'calculation_type': 'Sample Size',
                'hypothesis_type': 'Superiority',
                'method': 'simulation',
                'median1': 12.0,
                'median2': 18.0,
                'enrollment_period': 12.0,
                'follow_up_period': 12.0,
                'dropout_rate': 0.1,
                'alpha': 0.05,
                'power': 0.8,
                'allocation_ratio': 1.0,
                'nsim': 500,
                'seed': 42
            }
        },
        
        # Cluster RCT Binary
        {
            'module': 'app.components.cluster_rct',
            'function': 'generate_cli_code_cluster_binary',
            'params': {
                'calc_type': 'Power',
                'method': 'analytical',
                'n_clusters': 10,
                'cluster_size': 20,
                'icc': 0.05,
                'p1': 0.3,
                'p2': 0.5,
                'alpha': 0.05,
                'power': 0.8,
                'analysis_method': 'deff_ztest'
            }
        },
        
        # Cluster RCT Binary - Sample Size
        {
            'module': 'app.components.cluster_rct',
            'function': 'generate_cli_code_cluster_binary',
            'params': {
                'calc_type': 'Sample Size',
                'method': 'simulation',
                'cluster_size': 20,
                'icc': 0.05,
                'p1': 0.3,
                'p2': 0.5,
                'alpha': 0.05,
                'power': 0.8,
                'nsim': 1000,
                'seed': 42,
                'analysis_method': 'deff_ztest'
            }
        },
        
        # Cluster RCT Continuous
        {
            'module': 'app.components.cluster_rct',
            'function': 'generate_cli_code_cluster_continuous',
            'params': {
                'calculation_type': 'Power',
                'method': 'analytical',
                'n_clusters': 10,
                'cluster_size': 20,
                'icc': 0.05,
                'mean1': 3.0,
                'mean2': 3.5,
                'std_dev': 1.2,
                'alpha': 0.05,
                'power': 0.8,
                'analysis_model': 'ttest'
            }
        },
        
        # Cluster RCT Continuous - Sample Size
        {
            'module': 'app.components.cluster_rct',
            'function': 'generate_cli_code_cluster_continuous',
            'params': {
                'calculation_type': 'Sample Size',
                'method': 'simulation',
                'cluster_size': 20,
                'icc': 0.05,
                'mean1': 3.0,
                'mean2': 3.5,
                'std_dev': 1.2,
                'alpha': 0.05,
                'power': 0.8,
                'nsim': 1000,
                'seed': 42,
                'analysis_model': 'ttest'
            }
        }
    ]
    
    # Run all tests
    results = []
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n\nTest {i}/{len(test_cases)}: {test_case['function']}")
        print(f"Module: {test_case['module']}")
        print(f"Calculation Type: {test_case['params'].get('calculation_type', test_case['params'].get('calc_type', 'N/A'))}")
        print(f"Method: {test_case['params'].get('method', 'N/A')}")
        
        success = test_import_and_call_generator(
            test_case['module'],
            test_case['function'],
            test_case['params']
        )
        results.append({
            'test': f"{test_case['function']} ({test_case['params'].get('calculation_type', test_case['params'].get('calc_type', 'N/A'))})",
            'success': success
        })
    
    # Summary
    print(f"\n\n{'='*80}")
    print("TEST SUMMARY")
    print(f"{'='*80}")
    
    passed = sum(1 for r in results if r['success'])
    total = len(results)
    
    print(f"Total tests: {total}")
    print(f"Passed: {passed}")
    print(f"Failed: {total - passed}")
    print(f"Success rate: {passed/total*100:.1f}%")
    
    print(f"\nDetailed Results:")
    print("-" * 60)
    for result in results:
        status = "✅ PASS" if result['success'] else "❌ FAIL"
        print(f"{status} {result['test']}")
    
    if passed == total:
        print(f"\n🎉 All tests passed! All code generators are working correctly.")
        return 0
    else:
        print(f"\n❌ Some tests failed. Please check the generators.")
        return 1


if __name__ == "__main__":
    sys.exit(main())